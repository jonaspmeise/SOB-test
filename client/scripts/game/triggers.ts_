import { Trigger } from '../engine/types-engine';
import { BeyondPlayer, Lane, ShardsOfBeyondActionType } from './types-game';
import { GameEngine } from '../engine/engine';
import { PassAction, ConquerAction } from './actions.ts_';
import { OnlyOneCrystallizePerTurnRule, OnlyOnePlayPerTurnRule } from './rules.ts_';

// Triggers consume the type of an Action, the arguments of that action and the model state.
export const SHARDS_OF_BEYOND_TRIGGERS: Trigger<any, any>[] = [
  {
    name: 'Start of your Turn, you draw a Card.',
    actions: ['pass'],
    timing: 'after',
    effect: (engine: GameEngine<ShardsOfBeyondActionType>, actionType, parameters) => {
      // TODO: This is logic for "draw", not for this trigger!!!!
      if(parameters.nextPlayer.deck.length > 0) {
        // TODO: Allow selection here, whether this action should be executed nestedly or afterwards!
        return [() => engine.actions.draw(parameters.nextPlayer.deck.id)];
      }
      
      return [];
    }
  } as Trigger<typeof PassAction>,
  {
    name: 'When a Lane is full, the Player with Units that have most Power in that Lane conquers that Lane.',
    actions: [],
    timing: 'after',
    effect: (engine: GameEngine<ShardsOfBeyondActionType>, actionType, parameters) => 
      engine.types.get('lane')!
        .map(id => engine.components.get(id)! as Lane)
        .map(lane => {
          const winningPlayer = lane.wonByPlayer();

          if(winningPlayer === undefined) {
            return [];
          }

          const player = engine.components.get(winningPlayer)! as BeyondPlayer;

          if(!player.wonLanes.includes(lane.id)) {
            // Remove the Lane from the enemy, if they won it.
            const otherPlayer = engine.components.get(
              engine.types.get('player')!.find(id => id !== winningPlayer)!
            ) as BeyondPlayer;

            if(otherPlayer.wonLanes.includes(lane.id)) {
              otherPlayer.wonLanes = otherPlayer.wonLanes.filter(l => l !== lane.id);
            }

            return [() => engine.actions.conquer(winningPlayer, lane.id)];
          }

          return [];
        })
        .flat()
  } as Trigger<typeof ConquerAction>,
  {
    name: 'Start of each Turn: All Crystallize and Play- Limits are reset.',
    actions: ['pass'],
    timing: 'after',
    effect: (engine: GameEngine<ShardsOfBeyondActionType>, actionType, parameters) => {
      return [() => {
        OnlyOneCrystallizePerTurnRule.properties!.alreadyCrystallized = [0, 0];
        OnlyOnePlayPerTurnRule.properties!.alreadyPlayed = [0, 0];
      }];
    }
  } as Trigger<typeof PassAction>
  /*
  {
    name: 'When a Player has conquered four or more Lanes and controls more Lanes than their Opponent, they win the Game. If they both have more than four columns, it\'s a draw.!',
    // Always check this, regardless of Action! (technically needed for: Summon, Move, Return, Bury, Gain Power, ...)
    check: (actionType, args, model) => actionType === 'pass' && model.players.filter(player => player.wonLanes >= 4).length > 0,
    effect: (actionType, args, model) => {
      model.players.forEach(player => {
        const otherPlayer = model.players.filter(p => p.id !== player.id)[0];

        console.error('WON?', player, otherPlayer);
  
        if(player.wonLanes > otherPlayer.wonLanes) {
          alert(`${player} wins the Game!!!`);
        } else if(player.wonLanes === otherPlayer.wonLanes) {
          // TODO: This freezes and prevents rendering -> add a pipeline callback to the end? Like return [() => alert(....)] from here and call it from their after collecting all triggers.
          // TODO: (You can resolve the trigger order then!)
          alert('It\'s a draw!');
        } else {
          console.error('WWWWWWWWWWWWWWTF');
        }
  
        return [actionType, args, model];
      });
    }
  },*/
];